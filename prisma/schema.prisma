// This is your Prisma schema file for Supabase PostgreSQL
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model OrderLog {
  id                 String      @id @default(cuid())
  orderNumber        String      @map("order_number")
  status             OrderStatus @default(AWAITING_SHIPMENT)
  rawPayload         Json        @map("raw_payload")
  customerReachedOut Boolean     @default(false) @map("customer_reached_out")
  suggestedBox       Json?       @map("suggested_box") // { boxId, boxName, confidence, reason? }

  // Order classification & rate shopping fields
  orderType      String?   @map("order_type") // "SINGLE" | "BULK" | "EXPEDITED" | "ERROR"
  shippedWeight  Float?    @map("shipped_weight") // Total weight in lbs (box + products)
  preShoppedRate Json?     @map("pre_shopped_rate") // { carrierId, carrierCode, serviceCode, serviceName, price, deliveryDays, rateId }
  rateFetchedAt  DateTime? @map("rate_fetched_at")
  rateShopStatus String?   @map("rate_shop_status") // "SUCCESS" | "FAILED" | "SKIPPED"
  rateShopError  String?   @map("rate_shop_error") // Error message if rate shopping failed

  // Shipping & tracking fields
  trackingNumber String?   @map("tracking_number")
  carrier        String?
  labelUrl       String?   @map("label_url")
  labelCost      Float?    @map("label_cost")
  shippedAt      DateTime? @map("shipped_at")

  // Hold order fields
  onHoldReason String?   @map("on_hold_reason")
  onHoldUntil  DateTime? @map("on_hold_until")

  // Customer notification fields
  customerEmail      String?   @map("customer_email")
  notificationSent   Boolean   @default(false) @map("notification_sent")
  notificationSentAt DateTime? @map("notification_sent_at")

  // Address validation fields
  addressValidated  Boolean @default(false) @map("address_validated")
  addressOverridden Boolean @default(false) @map("address_overridden")

  // Archive fields
  archived   Boolean   @default(false)
  archivedAt DateTime? @map("archived_at")

  // Picking/Packing workflow fields
  batchId      String? @map("batch_id")
  chunkId      String? @map("chunk_id")
  binNumber    Int?    @map("bin_number") // 1-12 position on cart
  bulkBatchId  String? @map("bulk_batch_id") // Which bulk batch (for BULK orders)
  isPersonalized Boolean @default(false) @map("is_personalized") // Personalization flag from NetSuite

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  batch     PickBatch? @relation(fields: [batchId], references: [id], onDelete: SetNull)
  chunk     PickChunk? @relation(fields: [chunkId], references: [id], onDelete: SetNull)
  bulkBatch BulkBatch? @relation(fields: [bulkBatchId], references: [id], onDelete: SetNull)

  @@index([createdAt])
  @@index([orderNumber])
  @@index([customerReachedOut])
  @@index([status])
  @@index([trackingNumber])
  @@index([archived])
  @@index([orderType])
  @@index([rateShopStatus])
  @@index([batchId])
  @@index([chunkId])
  @@index([bulkBatchId])
  @@index([isPersonalized])
  @@map("order_logs")
}

enum OrderStatus {
  AWAITING_SHIPMENT
  ON_HOLD
  SHIPPED
  CANCELLED
  DELIVERED
  RETURNED
  RECEIVED
}

// Packer batch = up to 24 orders. Admin sends bulk groups to queue as chunked BulkQueueItems.
model BulkQueueItem {
  id                 String   @id @default(cuid())
  batchId            String?  @unique @map("batch_id") // Human-readable: "Bulk-000123" (6 digits = 1M capacity, numbers only)
  bulkGroupSignature String   @map("bulk_group_signature")
  chunkIndex         Int      @map("chunk_index")
  totalChunks        Int      @map("total_chunks")
  orderNumbers       Json     @map("order_numbers") // string[] - order numbers in this chunk (max 24)
  packageInfo        Json     @map("package_info") // { carrier, service, packaging, weight, dimensions }
  status             String   @default("PENDING") // PENDING | COMPLETED
  createdAt          DateTime @default(now()) @map("created_at")
  updatedAt          DateTime @updatedAt @map("updated_at")

  @@index([status])
  @@map("bulk_queue_items")
}

// Key-value app settings (order highlight rules, future settings).
model AppSetting {
  id        String   @id @default(cuid())
  key       String   @unique
  value     Json
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("app_settings")
}

// ============================================================================
// BOX CONFIG TABLES - for box fitting calculations
// ============================================================================

model Box {
  id            String   @id
  name          String
  lengthInches  Float    @map("length_inches")
  widthInches   Float    @map("width_inches")
  heightInches  Float    @map("height_inches")
  weightLbs     Float    @default(0) @map("weight_lbs")
  priority      Int      @default(1)
  active        Boolean  @default(true)
  inStock       Boolean  @default(true) @map("in_stock")
  singleCupOnly Boolean  @default(false) @map("single_cup_only")
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  feedbackRules  BoxFeedbackRule[] @relation("BoxFeedback")
  correctRules   BoxFeedbackRule[] @relation("CorrectBox")
  singleProducts ProductSize[]     @relation("SingleProductBox")

  @@index([active])
  @@index([priority])
  @@map("boxes")
}

model ProductSize {
  id           String   @id
  name         String
  lengthInches Float    @map("length_inches")
  widthInches  Float    @map("width_inches")
  heightInches Float    @map("height_inches")
  weightLbs    Float    @default(0) @map("weight_lbs")
  category     String   @default("other")
  active       Boolean  @default(true)
  singleBoxId  String?  @map("single_box_id")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  skuPatterns ProductSkuPattern[]
  skus        ProductSku[]
  singleBox   Box?                @relation("SingleProductBox", fields: [singleBoxId], references: [id], onDelete: SetNull)

  @@index([active])
  @@index([category])
  @@map("product_sizes")
}

model ProductSkuPattern {
  id            Int      @id @default(autoincrement())
  productSizeId String   @map("product_size_id")
  pattern       String
  createdAt     DateTime @default(now()) @map("created_at")

  productSize ProductSize @relation(fields: [productSizeId], references: [id], onDelete: Cascade)

  @@index([productSizeId])
  @@map("product_sku_patterns")
}
model ProductSku {
  sku           String   @id
  productSizeId String   @map("product_size_id")
  name          String?
  barcode       String?
  binLocation   String?  @map("bin_location") // Warehouse location e.g., "A11", "B23"
  active        Boolean  @default(true)
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  productSize ProductSize @relation(fields: [productSizeId], references: [id], onDelete: Cascade)

  @@index([productSizeId])
  @@index([binLocation])
  @@map("product_skus")
}

model BoxFeedbackRule {
  id             String   @id @default(cuid())
  comboSignature String   @map("combo_signature")
  boxId          String   @map("box_id")
  fits           Boolean
  correctBoxId   String?  @map("correct_box_id")
  testedAt       DateTime @default(now()) @map("tested_at")
  testedBy       String?  @map("tested_by")

  box        Box  @relation("BoxFeedback", fields: [boxId], references: [id], onDelete: Cascade)
  correctBox Box? @relation("CorrectBox", fields: [correctBoxId], references: [id], onDelete: SetNull)

  @@unique([comboSignature, boxId])
  @@index([comboSignature])
  @@index([boxId])
  @@map("box_feedback_rules")
}

// ============================================================================
// UNMATCHED SKU TRACKING - tracks SKUs that don't match any product
// ============================================================================

model UnmatchedSku {
  sku          String   @id
  firstSeen    DateTime @default(now()) @map("first_seen")
  lastSeen     DateTime @updatedAt @map("last_seen")
  occurrences  Int      @default(1)
  exampleOrder String?  @map("example_order")
  itemName     String?  @map("item_name")
  dismissed    Boolean  @default(false)

  @@index([dismissed])
  @@index([lastSeen])
  @@map("unmatched_skus")
}

// ============================================================================
// RATE SHOPPER - saved rate comparison configurations (like ShipStation)
// ============================================================================

model RateShopper {
  id                     String   @id @default(cuid())
  name                   String
  services               Json // Array of { carrierId, carrierName, serviceCode, serviceName }
  transitTimeRestriction String?  @map("transit_time_restriction") // "no_restriction", "1_day", "2_days", "3_days", "5_days", "7_days"
  preferenceEnabled      Boolean  @default(false) @map("preference_enabled")
  preferredServiceCode   String?  @map("preferred_service_code")
  preferenceType         String?  @map("preference_type") // "dollar" or "percentage"
  preferenceValue        Float?   @map("preference_value") // Dollar amount or percentage
  isDefault              Boolean  @default(false) @map("is_default")
  active                 Boolean  @default(true)
  createdAt              DateTime @default(now()) @map("created_at")
  updatedAt              DateTime @updatedAt @map("updated_at")

  @@index([active])
  @@index([isDefault])
  @@map("rate_shoppers")
}

// ============================================================================
// LOCATIONS - Ship-from warehouse locations for shipping labels
// ============================================================================

model Location {
  id           String   @id @default(cuid())
  name         String // e.g., "Main Warehouse", "Kansas City Fulfillment"
  company      String?
  addressLine1 String   @map("address_line1")
  addressLine2 String?  @map("address_line2")
  city         String
  state        String
  postalCode   String   @map("postal_code")
  country      String   @default("US")
  phone        String
  email        String?
  isDefault    Boolean  @default(false) @map("is_default")
  active       Boolean  @default(true)
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  @@index([active])
  @@index([isDefault])
  @@map("locations")
}

// ============================================================================
// USER MANAGEMENT
// ============================================================================

model User {
  id        String   @id @default(cuid())
  name      String
  email     String?  @unique
  pin       String?  // Quick login for shared iPads
  role      UserRole @default(PICKER)
  active    Boolean  @default(true)
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  pickedChunks  PickChunk[] @relation("ChunkPicker")
  shippedChunks PickChunk[] @relation("ChunkShipper")

  @@index([active])
  @@index([role])
  @@map("users")
}

enum UserRole {
  ADMIN
  PICKER
  SHIPPER
  ENGRAVER
}

// ============================================================================
// PICKING/PACKING WORKFLOW TABLES
// ============================================================================

// Cell - Physical picking station in warehouse
model PickCell {
  id        String   @id @default(cuid())
  name      String // e.g., "Cell A", "Cell B"
  active    Boolean  @default(true)
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Legacy: old batches had direct cellId. New batches use BatchCellAssignment.
  legacyBatches   PickBatch[]
  cellAssignments BatchCellAssignment[]

  @@index([active])
  @@map("pick_cells")
}

// Batch - Group of orders pushed to the queue for picking
model PickBatch {
  id              String          @id @default(cuid())
  name            String // Auto-generated: "SGL-Feb05-001", "BLK-Feb05-001", "OBS-Feb05-001"
  type            BatchType       @default(ORDER_BY_SIZE) @map("batch_type")
  cellId          String?         @map("cell_id") // Legacy - nullable for new multi-cell batches
  status          PickBatchStatus @default(ACTIVE)
  priority        Int             @default(0) // Lower = higher priority
  isPersonalized  Boolean         @default(false) @map("is_personalized")
  totalOrders     Int             @default(0) @map("total_orders")
  pickedOrders    Int             @default(0) @map("picked_orders")
  shippedOrders   Int             @default(0) @map("shipped_orders")
  engravedOrders  Int             @default(0) @map("engraved_orders") // Personalized only
  createdAt       DateTime        @default(now()) @map("created_at")
  releasedAt      DateTime?       @map("released_at") // Legacy
  completedAt     DateTime?       @map("completed_at")
  updatedAt       DateTime        @updatedAt @map("updated_at")

  // Legacy relation (old single-cell assignment)
  cell            PickCell?           @relation(fields: [cellId], references: [id], onDelete: SetNull)
  // New multi-cell assignment
  cellAssignments BatchCellAssignment[]
  chunks          PickChunk[]
  orders          OrderLog[]
  bulkBatches     BulkBatch[]

  @@index([cellId])
  @@index([status])
  @@index([priority])
  @@index([type])
  @@index([isPersonalized])
  @@map("pick_batches")
}

enum BatchType {
  SINGLES
  BULK
  ORDER_BY_SIZE
}

enum PickBatchStatus {
  DRAFT // Legacy - kept for backward compat
  RELEASED // Legacy - kept for backward compat
  ACTIVE // New: batch is available for pickers
  IN_PROGRESS
  COMPLETED
}

// Many-to-many: Batch <-> Cell assignment
model BatchCellAssignment {
  id        String   @id @default(cuid())
  batchId   String   @map("batch_id")
  cellId    String   @map("cell_id")
  priority  Int      @default(0) // Priority within this cell (lower = first)
  createdAt DateTime @default(now()) @map("created_at")

  batch PickBatch @relation(fields: [batchId], references: [id], onDelete: Cascade)
  cell  PickCell  @relation(fields: [cellId], references: [id], onDelete: Cascade)

  @@unique([batchId, cellId])
  @@index([batchId])
  @@index([cellId])
  @@index([priority])
  @@map("batch_cell_assignments")
}

// BulkBatch - Nested layer within a BULK PickBatch (tile > bulk batches > orders)
// Each represents a group of identical orders that maps to one row/shelf on the cart
model BulkBatch {
  id              String   @id @default(cuid())
  parentBatchId   String   @map("parent_batch_id") // FK to PickBatch (the tile)
  groupSignature  String   @map("group_signature") // Hash identifying identical orders
  orderCount      Int      @map("order_count") // How many identical orders in this split
  splitIndex      Int      @default(0) @map("split_index") // Which split (0, 1, 2...) if >24
  totalSplits     Int      @default(1) @map("total_splits")
  skuLayout       Json     @map("sku_layout") // Array of {sku, name, qty} for bin layout per row
  status          String   @default("PENDING") // PENDING | ASSIGNED | COMPLETED
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  parentBatch      PickBatch                  @relation(fields: [parentBatchId], references: [id], onDelete: Cascade)
  chunkAssignments ChunkBulkBatchAssignment[]
  orders           OrderLog[]

  @@index([parentBatchId])
  @@index([status])
  @@index([groupSignature])
  @@map("bulk_batches")
}

// Chunk - Unit of work assigned to a picker/cart
model PickChunk {
  id                  String          @id @default(cuid())
  batchId             String          @map("batch_id")
  chunkNumber         Int             @map("chunk_number") // Sequential within batch
  pickingMode         PickingMode     @default(ORDER_BY_SIZE) @map("picking_mode")
  status              PickChunkStatus @default(AVAILABLE)
  isPersonalized      Boolean         @default(false) @map("is_personalized")
  cartId              String?         @map("cart_id")
  // Legacy name-based fields (kept for backward compat)
  pickerName          String?         @map("picker_name")
  shipperName         String?         @map("shipper_name")
  // New user-based fields
  pickerId            String?         @map("picker_id")
  shipperId           String?         @map("shipper_id")
  ordersInChunk       Int             @default(0) @map("orders_in_chunk")
  ordersShipped       Int             @default(0) @map("orders_shipped")
  ordersSkipped       Int             @default(0) @map("orders_skipped")
  claimedAt           DateTime?       @map("claimed_at")
  pickingStartedAt    DateTime?       @map("picking_started_at")
  pickingCompletedAt  DateTime?       @map("picking_completed_at")
  shippingStartedAt   DateTime?       @map("shipping_started_at")
  shippingCompletedAt DateTime?       @map("shipping_completed_at")
  pickDurationSeconds Int?            @map("pick_duration_seconds")
  shipDurationSeconds Int?            @map("ship_duration_seconds")
  createdAt           DateTime        @default(now()) @map("created_at")
  updatedAt           DateTime        @updatedAt @map("updated_at")

  batch                PickBatch                  @relation(fields: [batchId], references: [id], onDelete: Cascade)
  cart                 PickCart?                   @relation(fields: [cartId], references: [id], onDelete: SetNull)
  picker               User?                      @relation("ChunkPicker", fields: [pickerId], references: [id], onDelete: SetNull)
  shipper              User?                      @relation("ChunkShipper", fields: [shipperId], references: [id], onDelete: SetNull)
  orders               OrderLog[]
  bulkBatchAssignments ChunkBulkBatchAssignment[]

  @@index([batchId])
  @@index([status])
  @@index([cartId])
  @@index([pickerId])
  @@index([pickingMode])
  @@map("pick_chunks")
}

enum PickingMode {
  SINGLES
  BULK
  ORDER_BY_SIZE
}

enum PickChunkStatus {
  AVAILABLE // Ready to be claimed
  PICKING // Picker is working on it
  PICKED // All items picked, ready for shipping
  READY_FOR_ENGRAVING // Personalized: picked, awaiting engraving
  READY_FOR_SHIPPING // Personalized: engraved, ready for shipping
  SHIPPING // Shipper is working on it
  COMPLETED // All orders shipped
  CANCELLED // Chunk was cancelled, orders returned to queue
}

// Links a chunk's shelf/row to a specific BulkBatch (for BULK picking mode)
model ChunkBulkBatchAssignment {
  id            String @id @default(cuid())
  chunkId       String @map("chunk_id")
  bulkBatchId   String @map("bulk_batch_id")
  shelfNumber   Int    @map("shelf_number") // 1, 2, or 3 (which row on the cart)

  chunk     PickChunk @relation(fields: [chunkId], references: [id], onDelete: Cascade)
  bulkBatch BulkBatch @relation(fields: [bulkBatchId], references: [id], onDelete: Cascade)

  @@unique([chunkId, shelfNumber])
  @@unique([chunkId, bulkBatchId])
  @@index([chunkId])
  @@index([bulkBatchId])
  @@map("chunk_bulk_batch_assignments")
}

// Cart - Physical picking cart with 12 bins (always 4 wide x 3 tall)
model PickCart {
  id        String         @id @default(cuid())
  name      String // e.g., "Cart 1", "Cart 2"
  color     String? // Optional color for identification
  status    PickCartStatus @default(AVAILABLE)
  active    Boolean        @default(true)
  createdAt DateTime       @default(now()) @map("created_at")
  updatedAt DateTime       @updatedAt @map("updated_at")

  chunks PickChunk[]

  @@index([status])
  @@index([active])
  @@map("pick_carts")
}

enum PickCartStatus {
  AVAILABLE // Cart is free to use
  PICKING // Cart is being used for picking
  PICKED_READY // Cart is picked and ready for shipping
  ENGRAVING // Cart is at engraving station (personalized)
  SHIPPING // Cart is being shipped
}
